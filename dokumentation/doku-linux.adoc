= Dokumentaion Linux LPIC 1

== Grundlegende Kommandos

- `whoami` - zeigt den aktuell angemeldeten Benutzer an
- `pwd` - zeigt das aktuelle Verzeichnis an
- `ls` - zeigt den Inhalt eines Verzeichnisses an
- `ls -a` - zeigt auch versteckte Dateien an
- `ls -l` - zeight ausführliche Informationen zu Dateien an
- `ls -t` - sortiert nach Änderungsdatum
- `ls -r` - kehrt Sortierreihenfolge um
- `cd <dir>` - _Change Directory_: wechselt in das Verzeichnis `<dir>`
- `su -l <user>` - _Substitute User_: wechselt in den Benutzeraccount `<user>`

== Hilfe auf der Kommmandozeile

- Option `--help` existiert für die meisten Kommandos

=== Manpages

Mit dem Kommando `man <commmand>` kann die Handbuchseite zum Kommando `<command>` aufgerufen werden. So gut wie *jedes* extern realisierte Kommando verfügt über eine Manpage.

Innerhalb der Manpage kann gesucht werden (`/` (vorwärts) bzw. `?` (rückwärts)).

Manpages sind in Abschnitte (_Sektionen_) unterteilt. 

Aufruf einer bestimmten Sektion mit

 man <sectionnumber> <command>

Beispiel:

 man 5 passwd

So erhält man Informationen über die *Datei* `passwd` und nicht über das *Kommando* `passwd`.

Manpages können (falls vorhanden) auch in einer anderen Sprache angezeigt werden:

 man -L de_DE.utf8 ls

== History

Jedes Kommando wird in der History der Shell gespeichert. Bei der BASH ist es z.B. die Datei `~/.bash_history`. Mit dem Kommando `history` kann eine Liste dieser Kommandos angezeigt werden. Jedes Kommando hat einen Index `<index>`. 

Ein bestimmtes Kommando kann folgendermaßen erneut aufgerufen werden:

 !<index>

Ansonsten kann mit den Cursor durch die History geblättert werden.

== Pfadangaben

Pfadangaben sind die "Wegbeschreibungen" zu Dateien oder Verzeichnissen. Es gibt zwei Arten von Pfadangaben:

- relative Pfadangaben sind immer ausgehend vom aktuellen Verzeichnis, beginnen also *nie* mit einem Slash `/`. 
- absolute Pfadangaben sind immmer ausgehend vom _Wurzelverzeichnis_ `/` und beginnen daher *immer* mit einem Slash `/`.


== Sonderzeichen 

Bestimmte Zeichen haben eine Sonderbedeutung für die BASH. Eins der wichtigsten Sonderzeichen ist der Leerschritt / Space. Dies ist das *Trennzeichen* für die Shell, trennt also z.B. ein Kommando und seine Optionen bzw. Argumente.

Andere Sonderzeichen sind z.B.:

- `*` _Asterisk_ steht für ein beliebiges Zeichen, dass *beliebig oft* vorkommen darf
- `?` _Fragezeichen_ steht für ein beliebiges Zeichen, dass *exakt einmal* vorkommen darf
- `!` History Expansion (s.u.)
- `$` Zeichen für eine Substitution (Variabelsubstitution, Kommandosubstitution ...)
- `\` _Escape Character_ maskiert das direkt darauf folgende Zeichen, hindert die Shell also daran, dieses mit einer Sonderbedeutung zu interpretieren
- `~` _Tilde_ symbolisiert das Heimatverzeichnis des aktuellen Benutzers
- etc.

=== Escapen / Maskieren von Sonderzeichen

Sonderzeichen können ihrer Sonderbedeutung durch _Escapen / Maskieren_ entledigt werden. Bzw. hindern wir die Shell daran dieses Sonderzeichen zu interpretieren.

Sonderzeichen können entweder mit dem Backslash `\` maskiert werden, oder in einfache oder doppelte Anführungszeichen gesetzt werden.

== externe/interne Kommandos

In der Regel sind Kommandos _extern_ realisiert, d.h. sie sind explizit installiert. Daneben gibt es aber auch _intern_ realisierte Kommandos, die sog. _Builtins_. Diese sind in die Shell eingebaut.

_Builtins_ verfügen (i.d.R.) über keine eigene Manpage, hier kann entweder die Option `--help` genutzt werden oder das Kommando `help`, z.B. `help cd`. 

Ansonsten finden sich alle Informationen dazu in der Manpage der BASH.

== mehr zu history

Alle eingegebenen Kommandos werden in der _history_ gespeichert. Zuerst im Speicher und letztlich beim Beenden der Shell in der Datei `~/.bash_history`.

Jeder reale Benutzer hat eine eigene History für die jeweilige Shell. So hat z.B. `root` eine eigene/andere _history_ als der reguläre Benutzer.

Einige wichtige Kommandos dazu:

* `history` ruft die gesamte history auf
* `history <anzahl>` zeigt nur die <anzahl> der letzten Einträge auf
* `!!` führt das letzte Kommando erneut aus
* `!<index>` führt Kommando mit index <index> aus
* `!<zeichenfolge>` führt letztes Kommando aus, das mit `<zeichenfolge>` beginnt 
* `!?<zeichenfolge>` führt letztes Kommando aus, das `<zeichenfolge>` enthält
* `!$` repräsentiert das letzte Argument des zuletzt eingegebenen Kommandos

Mit der Tastenkombination `<STRG>+R <zeichenfolge>` kann durch alle Einträge in der History geblättert werden, die `<zeichenfolge>` enthalten.

== Variablen

Erstellung einer Variablen und Zuweisung eines Wertes:

 my_var=hallo

Ausgabe des Inhalts einer Variablen (_Variablensubstitution_):

 echo $my_var

Das Dollarzeichen (`$`) ist wieder ein Sonderzeichen. Es weist die Shell an, eine _Substitution_ (Ersetzung) durchzuführen.

Variablen sind immer nur in der *aktuellen* Shell gültig, nicht in z.B. _Subshells_, also Shells, die innerhalt der aktuellen Shell gestartet werden.

Will man Variablen auch in Subshells verfügbar machen, so muss man diese _exportieren_:

 export my_env_var=überall

 my_var=hallo
 export my_var

Variablen sind so lange gültig, wie die Shell existiert, in der sie definiert wurden.

Variablen können mit `unset` gelöscht werden:

 unset my_var

== Dateioperationen

== mkdir

Mit dem Kommando `mkdir` können Verzeichnisse erstellt werden. Sollen in einem Rutsch mehrere Unterverzeichnisse erstellt werden, übergeben wir zusätzlich den Schalter `-p`.

 mkdir my_dir

 mkdir -p ~/my_dir/sub_dir/sub_sub_dir

== cp

- `cp <quelle> <ziel>` kopiert `<quelle>` nach `<ziel>`. Hierbei sind beides Dateien. Existiert `<ziel>` nicht, wird es erstellt, ansonsten ungefragt überschrieben.
- `cp -i <quelle> <ziel>` so wird vor dem Überschreiben eine Nachfrage eingeblendet
- `cp -r <verzeichnis> <ziel>` beim Kopieren von Verzeichnissen muss die Aktion _rekursiv_ durchgeführt werden (Option `-r`)
- `cp -u <quelle> <ziel>` ersetzt `<ziel>` nur dann, wenn `<quelle>` neuer ist bzw. überhaupt Unterschiede vorhanden sind
- `cp -p <quelle> <ziel>` behält Dateiatribute (Bestizer, Rechte, Timestamp) bei
- `cp -a <quelle> <ziel>` behält auch Dateiatribute bei, enthält zusätzlich die Option `-r`.

== mv

Mit `mv` können Dateien verschoben und umbenannt werden.

- `mv <quelle> <ziel>` verschiebt `<quelle>` nach `<ziel>`
- `mv <quelle> <ziel>` benennt `<quelle>` in `<ziel>` um
- Für `mv` gibt es keine Option `-r`. Sowohl `<quelle>` als auch `<ziel>` können Verzeichnisse sein. 
- auch für `mv` gibt es die Option `-i`

== rm

- `rm <datei>` löscht `<datei>` ohne Nachfrage
- `rm -r <verzeichnis>` löscht `<verzeichnis>`
- auch für `rm` gibt es die Option `-i`

== rmdir

löscht *leere* Verzeichnisse

== Aliase

Abkürzungen für z.B. längere/häufig benutzte Kommandos

 alias ll='ls -l'
 alias la='ls -a'

Alias löschen:

 unalias ll

Alle Aliase anzeigen:

 alias

Aliase sind nur in der Shell gültig, in der sie definiert wurden. Analog zu Variablen.

Aliase können persistent konfiguriert werden, z.B. in der Datei `~/.bashrc` bzw. in `~/.bash_aliases`

Nach Änderungen muss die Datei `~/.bashrc` neu eingelesen werden. Dies geschieht automatisch beim Start einer neuen BASH oder alternativ mit dem Kommanod `source` bzw. dessen Abkürzung `.`

 source ~/.bashrc
 . ~/.bashrc

== Konfigurationsdateien

=== Benutzerspezifische 

- sind immer im Heimatverzeichnis des Nutzers
- beginnen immer mit einem Punkt bzw. befinden sich in einem Verzeichnis, das mit einem Punkt beginnt

=== Systemweite

- *alle* systemweiten Konfigurationsdateien befinden sich im Verzeichnis `/etc`

== Textströme 

== UNIX-Philosophie

1. Schreibe Programme so, dass sie *eine* Aufgabe erledigen, und diese gut machen
2. Schreibe Programme so, dass sie zusammenarbeiten
3. Schreibe Programme so, dass sie Textströme verarbeiten, denn Text ist eine universelle Schnittstelle

== Standardkanäle 

- Standardeingabekanal - `stdin` - Kanalnr. 0
- Standardausgabekanal - `stdout` - Kanalnr. 1
- Standardfehlerkanal - `stderr` - Kanalnr. 2

== Redirect

Mit einem Redirect kann ein Datenstrom in eine Datei umgeleitet werden.

- `>` Mit einem _einfachen_ Redirect wird der Standardausgabekanal oder der Standardfehlerkanal in eine Datei umgeleitet. Die Datei muss vorher nicht existiert haben, sie wird ggf. erzeugt. Eine bereits bestehende Datei wird zuerst geleert/der Inhalt gelöscht und anschließend mit dem Inhalt des Datenstroms beschrieben.

 ls /etc 1> ausgabe_ls.txt     # stdout(1) in datei
 ls /etc > ausgabe_ls.txt     # stdout(1) in datei

 ls /gibtsnicht 2> fehler_ls.txt     # stderr(2) in datei

- `>>` Mit einem _doppelten_ (anhängenden) Redirect wird der Inhalt des Datenstroms (`stdout` oder `stderr`) an eine bereits bestehende Datei angehängt. Eine nicht existierende Datei würde erzeugt werden.
- `&>` So werden sowohl `stdout` als auch `stderr` in eine Datei umgeleitet

 ls /etc /gibtsnicht &> ausgabe_und_fehler.txt

`sterr` wird in `stdout` umgeleteitet und dann `stdout` in datei
das `&1` ist nötig, damit der Shell klar ist, dass der Kanal 1 gemeint ist
ansonsten würde die Datei `1` erstellt werden

 ls /etc /gibtsnicht > ausgabe_und_fehler.txt 2>&1    

- `<` Mit dem umgedrehten Redirect kann der Inhalt einer Datei an den Eingabekanal eines Kommandos geleitet werden

 mail -s Mail_Subject empfaenger@mail.example < mailinhalt.txt

== Pipe

Mit der Pipe `|` wird der Ausgabekanal eines Kommandos an den Eingabekanal eines weiteren Kommandos umgeleitet.

- `<Kommando1> | <kommando2>`

 ls -l /etc | less
 grep alias ~/.bashrc | grep -v `#`

== Filterkommandos

Wir nutzen Filterkommandos um aus einem Textstrom den Inhalt zu herauszufiltern, den wir haben wollen 

=== grep

Alle Zeilen anzeigen, die das Pattern `alias` enthalten. Es wird immer die gesamte Zeile ausgegeben in der das Pattern vorkommt.

 grep 'alias' ~/.bashrc

Gesamten Inhalt der Datei `~/.bashrc` anzeigen, Kommentarzeilen *nicht* mit ausgeben

 grep -v `#` ~/.bashrc 

- `grep -i <pattern>`: Gross- und Kleinschreibung von `<pattern>` ist egal
- `grep -n <pattern>`: Anzeige der Zeilennummer, in der `<pattern>` gefunden wurde
- `grep -r <pattern> dir/`: Rekursive Suche, so kann über alle Dateien in einem Verzeichnis _gegrept_ werden
- `grep -v <pattern>`: _inVert match_: Ausgabe wird _invertiert_, also nur die Zeilen ausgegeben, in denen `<pattern>` *nicht* vorkommt
- `grep -c <pattern>`: gibt nicht die Zeilen aus, sondern nur die Anzahl der Zeilen in denen `<pattern>` vorkommt

=== cut

Mit `cut` können wir Spalten/Felder/_Fields_ aus tabellarisch aufgebauten Dateien _ausschneiden_ bzw. filtern. Die wichtigen Optionen für `cut` sind `-d` zur Angabe des Trennzeichens (_Delimiter_) und `-f` zur Angabe der Spalte (_Field_). Bsp.:

Ausschließlich die Login-Namen anzeigen lassen:

 cut -d: -f1 /etc/passwd

=== weitere Filterkommandos

- `tr`: übersetzt ein Zeichen in einem Textstrom (es können keine Dateien als Argument übergeben werden) in ein anderes/löscht dieses etc... 

 tr a A < datei.txt  # wandelt jedes kleine a in ein grosses A um

- `wc`: gibt die Anzahl der Zeilen, Wörter und Bytes einer Datei an 

 wc -l /etc/passwd`  # Anzahl Zeilen der Datei /etc/passwd

== Kommandosubstitution

`$(kommando)`: `kommando` wird in einer Subshell ausgeführt und durch das Ergebnis (`stdout`) ersetzt

----
var=date
echo $var
> date   # String/Zeichenkette date wird ausgegeben
----

----
var=$(date)
echo $var
> Tue May 23 03:42:43 PM CEST 2023   # aktuelles Datum wird ausgegeben
----

Beispiel: Speichern eines Timestamps in einer Variablen:

 timestamp=$(date +%Y%m%d)

Es gibt auch eine ältere Syntax:

 timestamp=`date +%Y%m%d`

Ein etwas komplexeres Beispiel:

 echo -e "Hallo, ich bin $(grep ${USER} /etc/passwd | cut -d: -f5 | cut -d, -f1).\n\nHeute ist der $(date '+%d.%m.%Y, %H:%M')." > username.txt

== echo 

- `echo -e`: so kann `echo` gewisse Steuerungszeichen interpretieren, um z.B. einen Zeilenumbruch zu erzeugen, einen horizontalen Tab etc.
- diese Steuerungszeichen / Sequenzen beginnen mit einem `\` (Backslash)
- `echo -e '\n'`: `echo` gibt eine (zusätzliche) Leerzeile aus (`echo` an sich führt bereits einen Zeilenumbruch am Ende der Ausgabe aus, so erhalten wir also zwei Leerzeilen) 
- `\n` muss in diesem Fall _escaped/maskiert/gequotet_ werden, damit nicht die BASH, sondern das Kommando an sich (`echo`) den Backslash als Sonderzeichen interpretieren kann
- der Backslash muss sozusagen vor der Shell "versteckt" werden
- das Escapen kann sowohl durch Einfassen in einfache oder doppelete Anführungszeichen (`'` oder `"`) erfolgen, oder durch die Voranstellung eines Backslashs (`\`)

 echo -e '\n'
 echo -e "\n"
 echo -e \\n

== Dateisystembaum unter Linux

_Filesystem Hierarchy Standard_ - FHS: Eine Empfehlung an alle Distributionen, wie der Dateisystembaum unter UNIX/Linux aufgebaut sein sollte.

- `/bin`: common executables available for everyone, `ex. cp rm ls`
- `/boot`: kernel and boot configuration, initial ramdisk, kernel image
- `/dev`: files which point to both physical and pseudo devices, populated by `udev`
- `/etc`: systemwide configuration files
- `/home`: non-root user home directories
- `/lib`: library files used by the system, include `.so` files and others
- `/lib32`: library files used by the system, include `.so` files and others
- `/lib64`: library files used by the system, include `.so` files and others
- `/lost+found`: saved files due to failure, not relevant for users, just for the system
- `/media`: auto-mounting place for certain external devices on some distros
- `/mnt`: place to mount various file systems
- `/opt`: various software, not installed by package manager
- `/proc`: virtual filesystem (`procfs`) for resources, processes, and more, only in memory, not actual files on hard disk
- `/root`: root user home directory
- `/sbin`: similar to `/bin`, but for system administrators, ex. `fdisk`
- `/tmp`: temporary file storage, wiped out after reboot
- `/usr`: user programs, library files, docs, etc.
- `/var`: variable files for various purposes, ex. logs, tz data, files for webserver (debian)
- `/vmlinuz`: boot/vmlinuz-4.15.0-43-generic: compressed linux kernel 

=== weitere wichtige Verzeichnisse (nicht Bestandteil des FHS)

- `/sys`: virtual filesystem (`sysfs`), extension to `/proc`
- `/run`: virtual filesystem, was under `/var/run` (symlinked) before, applications can store data needed to operate, e.g. `.lock` files

== Prozesse

Ein Prozess ist ein sich in der Auführung befindliches Programm. Ein Programm resultiert immer in mindestens einem Prozess. Prozesse laufen jeweils in einem von anderen unabhängigen "Resourcenraum", haben eine eigene _PID_, kennen nur die _PID_ des Prozesses, von dem sie gestartet wurden (Elternprozess). Prozesse können mit dem Kommando `kill` über _Signale_ beeinflusst werden.

Wird der Elternprozess beendet, so werden (in der Regel) gleichzeitig alle Kindprozesse mit beendet.

Auf der Shell kann immer nur ein einzelner Prozess im _Vordergrund_ ausgeführt werden. Prozesse können mit der Tastenkomnination `STRG+Z` angehalten und in den Hintergrund geschickt werden. Mit dem Kommando `bg` kann dieser Prozess dann im Hintergund fortgesetzt werden, `fg` holt den Prozess in den Vordergrund zurück. 

Wir können einen Prozess beim Start aber auch direkt in den Hintergrund schicken und starten (duch Anhängen eines `&`):

 kommando &

- `ps -aux`: Anzeige aller laufende Prozessez
- `ps -ef`: auch Anzeige aller laufenden Prozesse
- `ps --forest`: Prozesshirarchie (Baumstruktur) anzeigen
- `jobs`: Anzeigen der Hintergrundprozesse
- `fg`: letzten/aktuellen/default Job in den Vordergrund holen
- `fg %<jobnummer>`: Job mit Jobnummer `<jobnummer>` in den Vordergrund holen
- `bg`: Hintergrundprozess fortsetzen
- `bg %<jobnummer>`: Hintergrundprozess mit Jobnummer `<jobnummer>` in fortsetzen

== kill

`kill` sendet Signale an Prozesse. Es muss die PID des Prozesses angegeben werden, Prozessname funktioniert nicht.

- `kill -s <signal> <PID>`: sendet <signal> an den Prozess mit der PID <PID>
- `kill -<signal> <PID>`: sendet <signal> an Prozess mit der PID <PID>

Die PID eines Prozesses kann auf mehrere Arten ermittelt werden:

 ps -ef | grep <prozessname>
 pgrep <prozessname>
 ...

=== einige wichtige Signale

- `SIGTERM` (15): Standard, falls kein bestimmtes Signal angegeben wird. Sendet eine "freundliche" Aufforderung an den Prozess, sich doch bitte zu beenden. Im Prozess selbst ist festgelegt, wie er sich beendet, z.B. werden noch gewisse Aufräumarbeiten durchgeführt etc.
- `SIGINT` (2): sendet eine etwas deutlichere Aufforderung an den Prozess, sich zu beenden, wird bei der Tastenkomnination `STRG+C` (_Cancel_) gesendet
- `SIGKILL` (9): rabiateste Methode, Signal wird nicht an den Prozess, sondern direkt an den Scheduler gesendet, der daraufhin den entsprechenden Prozess aus seiner Liste löscht, der Prozess somit keine CPU Zeit mehr zur Verfügung gestellt bekommt und somit zwangsläufig beendet wird.
- `SIGSTOP` (19): hält Prozess an und schickt ihn in den Hintergrund (`STRG+Z`)
- `SIGCONT` (18): startet angehaltene Prozesse

=== pkill und killall

- `pkill`: analog zu oben, `pkill` erwartet aber den Namen bzw. einen Teil des Namens eines Prozesses anstatt der PID. Falls mehere Prozesse auf den Namen passen, wird das Signal an *alle* diese Prozesse gesendet.
- `killall` auf neueren Distributionen nicht mehr vorhanden, ähnliches Verhalten wie `pkill`

== Benutzer und Gruppen

=== Benutzer 

Es gibt zwei Arten von Bentuzern: 

- _Reale Benutzer_ : Haben in der `/etc/passwd` eine Login-Shell (z.B. BASH) zugewiesen. Diese Benutzer können sich also interaktiv am System anmelden und Kommondos ausführen. Auf den meisten Distributionen beginnen deren UIDs mit 1000, sind also vierstellig
- _Systembenutzer_: Haben *keine* Login-Shell zugewiesen (`/usr/sbin/nologin`), sie können sich also *nicht* am System anmelden und sind dafür gedacht, dass Dienste unter ihrem Benutzerkontext laufen. 

==== Benutzer anlegen

Das Kommanod `useradd` ist auf allen Distributionen verfügbar und ist der Standart zum Anlegen neuer Benutzer. 

Auf Debian-basierten Distributionen gibt es den _Wrapper_ `adduser`, also ein (Perl-) Skript, welches intern wiederum `useradd` nutzt, allerdings arbeitet es _interaktiv_, fragt also gewisse Einstellungen ab, diese müssen nicht direkt über Optionen angegeben werden.

Weiterhin ruft `adduser` das Kommando `passwd` auf, so dass beim Anlegen eines Benutzers gleichzeitig ein Passwort festgelegt wird.

Beispiel für das Anlegen eines Bentuzers mit `useradd`.

 useradd -m -c 'Tux Tuxedo' -s /bin/bash tux

- `-m`: Heimatverzeichnis unter `/home` mit gleichem Namen wie User anlegen und Standarddateien aus `/etc/skel` dorthin kopieren
- `-c`: Kommentarfeld, z.B. voller Name des Benutzers
- `-s`: Login-Shell

Anschließend muss noch das Kommando `passwd <user>` aufgerufen werden, um dem Benutzer ein Passwort zuzuweisen. Ansonsten kann sich der neue User nicht anmelden.

==== relevante Dateien beim Anlegen von Benutzern

- `/etc/passwd`: hier werden alle User aufgelistet mit Grundeinstellugen (UID, GID, Heimatverzeichnis, Login-Shell etc.)
- `/etc/shadow`: verschlüsselte und gesaltete Passwörter der Benutzer, Ablaufzeiten des Passworts
- `/etc/group`: Liste der Gruppen und deren Mitglieder
- `/etc/gshadow`: Passwörter für Gruppen (wird jedoch nicht genutzt)

=== Benutzer wechseln

`su`: _Substitute User_ Benutzer wechseln

- `su tux`: Wechselt in den Benutzeraccount von `tux`, Umgegung (env, Variablen etc.) werden teilweise neu gesetzt, aber nicht alle.
- `su - tux`: wie oben, es werden aber alle Umgebungsvariablen neu gesetzt (auch `$PATH`) ("echte" Login Shell)
- `su -l tux`: wie oben
- `su --login tux`: wie oben

=== Gruppen

- beim Anlegen eines Benutzers wird (auf den meisten Distributionen) eine Gruppe erstellt, die genauso heißt wie der Benutzer. Dies ist die _primäre_ oder _initiale_ Gruppe des Users.
- ein User kann beliebig vielen _sekundären_ Gruppen angehören
- Gruppen können nur einzelne User enthalten, keine weiteren Gruppen

Gruppen können mit dem Kommando `groupadd` erstellt werden

 groupadd gfn 

Benutzer `tux` der Gruppe `gfn` hinzufügen:

 usermod -aG gfn tux

Wichtig ist hier das `-a` (_append_), ansonsten werden alle anderen Gruppenzugehörigkeiten von `tux` gelöscht (bis auf die _primäre_ Gruppe).

*Wichtig:* Gruppenzugehörigkeiten werden erst aktiv, wenn sich der Benutzer einmal komplett vom System ab- und wieder angemeldet hat.

=== Besitzer / Gruppe von Dateien ändern

Besitzer auf `tux` ändern:

 chown tux file.txt

Besitzer auf `tux` und Gruppe auf `users` ändern:

 chown tux:users file.txt

Nur Gruppe auf `users` ändern:

 chown :users file.txt
 chgrp users file.txt

== Rechteverwaltung

- `r` read
- `w` write
- `x` eXecute

Im Listing von `ls -l`:

 -rw-r--r-- 1 tux tux 27 Nov  6 10:50 file.txt

Das erste Minuszeichen (`-`) gibt an, dass es sich um eine reguläre Datei handelt, hier könnte aber auch ein `d` für _Directory_ stehen oder ein `b` für _Block Device_, ein `l` für _Symbolic Link_ etc.

Es folgen die Berechtigungen für User, Group und Others:

 User Group Others
 rw-  r--   r--

=== Bedeutung der Berechtigungen

Angewandt auf Dateien:

- `r` Inhalt der Datei lesen
- `w` Inhalt der Datei verändern
- `x` Datei ausführen

Angewandt auf Verzeichnisse:

- `r` Inhalt des Verzeichnisses lesen
- `w` Dateien oder Verzeichnisse erstellen oder löschen
- `x` Verzeichniss betreten

=== Symbolische Rechtevergabe

Hier werden _Symbole_ verwendet:

- `r` read
- `w` write
- `x` eXecute
- `u` User
- `g` Group
- `o` Others
- `a` All (`ugo`)
 
Berechtigungen können hinzugefügt (`+`), entfernt (`-`) oder gesetzt (`=`) werden.

Beispiele:

 chmod u-w file.txt             # Schreibrecht für den User entfernen
 chmod g+w file.txt             # Schreibrecht für die Gruppe hinzufügen
 chmod go-x file.txt            # Gruppe und Ohters das Ausführungsrecht entziehen
 chmod u=rwx,g=rw,o=r file.txt  # Rechte für User auf rwx setzen, für Gruppe auf rw und Ohters auf r

Die symbolische Rechtevergabe eignet sich also vor allem dafür, wenn einzelne Rechte hinzugefügt oder entfernt werden sollen, die anderen Rechte beibehalten werden.

=== Numerische / Oktale Rechtevergabe

- `r` read    -> 4
- `w` write   -> 2
- `x` eXecute -> 1

Bei der numerischen Rechtevergabe können nur *alle* Rechte auf einmal gesetzt werden, also für User, Group und Others gleichzeitig. Die Werte der Rechte werden dabei addiert:

       ugo
 chmod 640 file.txt

Ist gleichbedeuten mit:

 chmod u=rw,g=r,o-rwx file.txt

==== Herkunft/Erklärung 

 Okt. Binär

  1   001
  2   010
  4   100

Gut zu sehen am Listing von `ls -l`. Ist das entsprechende Recht gesetzt, ist auch ein Bit (im Speicher) gesetzt:

  6   4   4
 110 100 100
 rw- r-- r--

== Standardberechtigungen 

Sinnvolle Vollberechtigungen:

- auf Dateien: 666
- auf Verzeichnisse: 777

=== umask

Die `umask` gibt an, welche Berechtigungsbits *nicht* gesetzt sind, ausgehend von den _sinvollen Vollberechtigungen_ (s.o.).

Die `umask` kann von jedem Benutzer selbst gesetzt werden, entweder durch einen Aufruf in der Shell (ist dann auch nur für die aktuelle Shell gültig) oder durch den Eintrag in einer Datei (Standard: `~/.profile`).

*Wichtig:* Die `umask` wird *nicht subtrahiert*, wie z.B. im LPIC-1 Buch oder Internet beschrieben. Vielmehr ist es die Negation und logische UND-Verknüpfung:

Verzeichnisse:

 111111111   -> 777
 111101101   -> 022 negiert
 ---------
 111101101   -> logisches UND
  7  5  5

Dateien:

 110110110   -> 666
 111101101   -> 022 negiert
 ---------
 110100100   -> logisches UND
  6  4  4

== Sonderbits

- https://de.wikipedia.org/wiki/Unix-Dateirechte#Beispiele

=== SUID Bit

Angewandt auf eine _ausführbare Binärdatei_ (gilt *nicht* für Skripte), sorgt das SUID-Bit dafür, dass das Kommando im Berechtigungskontext des Besitzers der Datei ausgeführt wird, nicht aber im Berechtigungskontext des aufrufenden Benutzers.

Beispiel `/usr/bin/passwd`:

`passwd` schreibt das neue Passwort in die Datei `/etc/shadow`, hier hat aber nur `root` Schreibrechte. Ohne das SUID-Bit kann das neue Passwort nicht in die Datei geschreiben werden.

 ls -l /etc/shadow
 -rw------- 1 root root 1060 Oct  9 14:53 /etc/shadow

 ls -l /usr/bin/passwd
 -rwsr-xr-x 1 root root 80768 Sep 24 14:50 /usr/bin/passwd

Das kleine `s` gibt an, dass sowohl das SUID Bit als auch das Ausführugnsbit gesetzt sind. Würde das Ausführungsbit fehlen, stünde hier ein grosses `S`.

=== SGID Bit

Angewandt auf eine _ausführbare Binärdatei_ (gilt *nicht* für Skripte), sorgt das SGID-Bit dafür, dass das Kommando im Berechtigungskontext der Gruppe der Datei ausgeführt wird, nicht aber im Berechtigungskontext des aufrufenden Benutzers.

Angewandt auf ein Verzeichnis sorgt das SGID-Bit dafür, dass neue erstellte Dateien der Gruppe zugeornet werden, die auch dem Verzeichnis zugeordnet ist und nicht der initialen Gruppe des Users, der die Datei erstellt.

Beispiel `/var/mail`:

 ls -l /var/mail
 -rwxrwsr-x 1 root root 10 Sep 18 15:18 /var/mail

=== Sticky Bit

Auf ein Verzeichniss angewandt, sorgt das Sticky Bit dafür, dass nur der Besitzer einer Datei diese Datei verändern oder löschen kann.

Beispiel: 

 /tmp

 ls -ld /tmp
 drwxrwxrwt 17 root root 440 Nov 10 11:27 /tmp

=== Oktalwerte und Symbole der Sonderbits

 SUID:   4   u+s
 SGID:   2   g+s
 Sticky: 1   o+t


== Paketmanagement Debian

Unter Debian basierten Distributionen wird der Paketmanager `apt` bzw. `apt-get` verwendet. Im Hintergund nutzen beide aber das Low-Level-Tool `dpkg`. Dieses hat unter anderem folgende Einschränkungen:

- kein Zugriff aufs Internet, Pakete müssen manuell heruntergeladen werden
- Abhängigkeiten können also nicht automatisch aufgelöst werden
- `dpkg` gibt aber Hinweise auf fehlende Abhängigkeiten

=== Debian Paketmanagement

- `dpkg -i <datei>.deb`: Paket `<datei>` installieren (oder Update falls Paket schon installiert)
- `dpkg -I <datei>.deb`: Informationen über Paket `<datei>.deb`
- `dpkg --info <datei>.deb`: Informationen über Paket `<datei>.deb`
- `dpkg -r <paket>`: Paket `<paket>` entfernen/deinstallieren (Konfigurationsdateien bleiben erhalten)
- `dpkg -P <paket>`: Paket `<paket>` entfernen/deinstallieren (_purge_) (Konfigurationsdateien werden mit entfernt)
- `dpkg -l`: Liste aller auf dem System installierten Pakete inkl. Status (installiert, entfernt, teilweise installiert/entfernt ...)
- `dpkg --list`: Liste aller auf dem System installierten Pakete inkl. Status (installiert, entfernt, teilweise installiert/entfernt ...)
`dpkg -l <glob-pattern>`: Liste aller Pakete, die auf `<glob-pattern>` passen 
- `dpkg --get-selections`: übersichtliche Liste aller installierten Pakete
- `dpkg -L <paket>`: Liste aller im Paket `<paket>` enthaltener Dateien
- `dpkg --list-files <paket>`: Liste aller im Paket `<paket>` enthaltener Dateien
- `dpkg -s`: Statusinformationen aller auf dem System installierten Pakete
- `dpkg -s <paket>`: Statusinformationen von `<paket>`
- `dpkg -S /path/to/file`: Angabe, zu welchem Paket `/path/to/file/` gehört

=== Troubleshooting

Bei fehlerhaften oder nur teilweise installierten Paketen können wir folgende Option von `apt` nutzen:

 apt install -f
 apt install --fix-broken

=== Paketquellen

`Archive type`:: A repository may contain packages with ready-to-run software (binary packages, type deb) or with the source code to this software (source packages, type deb-src). The example above provides binary packages.

`URL`:: The URL for the repository.

`Distribution`:: The name (or codename) for the distribution for which packages are provided. One repository may host packages for multiple distributions. In the example above, disco is the codename for Ubuntu 19.04 Disco Dingo.

`Components`:: Each component represents a set of packages. These components may be different on different Linux distributions. For example, on Ubuntu and derivatives, they are:

`main`:: contains officially supported, open-source packages.

`restricted`:: contains officially supported, closed-source software, like device drivers for graphic cards, for example.

`universe`:: contains community maintained open-source software.

`multiverse`:: contains unsupported, closed-source or patent-encumbered software.

On Debian, the main components are:

`main`:: consists of packages compliant with the Debian Free Software Guidelines (DFSG), which do not rely on software outside this area to operate. Packages included here are considered to be part of the Debian distribution.

`contrib`:: contains DFSG-compliant packages, but which depend on other packages that are not in main.

`non-free`:: contains packages that are not compliant with the DFSG.

`security`:: contains security updates.

`backports`:: contains more recent versions of packages that are in main. The development cycle of the stable versions of Debian is quite long (around two years), and this ensures that users can get the most up-to-date packages without having to modify the main core repository.

=== apt-get

- `apt-get update`: Paketindex auf den neuesten Stand bringen
- `apt-get upgrade`: alle Pakete aktualisieren. Es werden aber keine neuen Pakete installiert oder vorhandene entfernt.
- `apt-get dist-upgrade`: wie `upgrade`, es werden aber ggf. neue Pakete installiert oder vorhandene entfernt.
- `apt-get remove`: Paket entfernen, Konfigurationsdateien bleiben erhalten
- `apt-get remove --purge`: Paket entfernen, Konfigurationsdateien werden mit entfernt
- `apt-get purge`: Paket entfernen, Konfigurationsdateien werden mit entfernt
- `apt-get autoremove`: alle Pakete entfernen, die automatisch installiert wurden (als Abhängigkeit) und von keinem weiteren Paket benötigt werden.
- `apt-get clean`: `.deb` Pakete löschen
- `apt-cache search`: nach Paketen suchen, akzeptiert RegEx, durchsucht Paketnamen und Beschreibung
- `apt-cache show`: Informationen über ein Paket
- `apt-file`: Muss zusätzlich installiert werden 
- `apt-file search `: Kann herausfinden, welches Paket `<datei>` bereitstellt 
- `apt-file update `: Paketindex von `apt-file` aktualiseren

== Paketmanagement Red hat

=== rpm

- kann Programme installieren, die lokal auf dem System vorliegen
- die Pakete müssen dafür in einem bestimmten Binärformat vorliegen (`.rpm`)
- Abhängigkeiten können nicht automatisch aufgelöst werden
- fehlende Abhängigkeiten werden allerdings aufgelistet (jedoch nur die Dateien
  an sich, nicht die fehlenden _Pakete_)
- `-v` verboser Output
- `-h` Hashtags (`#`) als Fortschrittsanzeige

Installation eines Pakets:

----
rpm -i PACKAGENAME
rpm -i gimp-2.8.22-1.el7.x86_64.rpm
----

=== Update

Ein Paket aktualisieren

----
rpm -U PACKAGENAME
----

- ist kein Paket mit diesem Namen vorhanden, wird es trotzdem die neues Version installiert.
- dies kann mit der Option `-F` verhindert werden

=== Deinstallation

----
rpm -e PACKAGE    # erase
rpm -e wget
----

=== Installierte Pakete anzeigen

Alle installierten Pakete anzeigen

----
rpm -qa      # query all
----

=== Informationen über Pakete erhalten

Informationen über ein installiertes Paket:

----
rpm -qi unzip       # query information
----

Informationen darüber, welche `Dateien` in einem Paket enthalten sind:

----
rpm -ql unzip      # query list
----

Informationen über ein `noch nicht` installiertes Paket, hier kann eine FTP-Adresse oder URL angegeben werden:

----
rpm -qip atom.x86_64.rpm           # query information not installed
----

----
rpm -qlp atom.x86_64.rpm     # query list not installed
----


=== Zu welchem Paket gehört eine Datei

----
rpm -qf /usr/bin/unzip       # query file
> unzip-6.0-19.el7.x86_64
----

== YellowDog Updater Modified (yum)

Unterschied zu Debian: Der Paketindex wird automatisch aktualisiert. 

=== nach Paketen suchen

----
yum search PATTERN

yum search 7zip
----

=== Installation, Upgrade, Removal

Ohne die Angabe eines Paketnamens wird das gesamte System aktualisiert. Es gibt *kein* `yum upgrade`!

----
yum update
----

----
yum install p7zip
----

----
yum update wget
----

----
yum check-update PACKAGENAME
yum check-update                # gesamtes System
----

=== Pakete nur herunterladen

----
yum install --downloadonly <package>
yum install --downloadonly --downloaddir=<directory> <package>
----

=== zu welchem Paket gehört eine Datei

----
yum whatprovides DATEI
yum whatprovides libgimpui-2.0.so.0
----

Funktioniert auch mit Dateien:

----
yum whatprovides /etc/hosts
----

=== Informationen über ein Paket erhalten

----
yum info firefox
----

=== Software Repositories

- Repos sind in `/etc/yum.repos.d` zu finden, z.B. `CentOS-Base.repo`
- Repos können hinzugefügt werden, indem eine `.repo` Datei dort abgelegt wird (oder am Ende von `/etc/yum.conf`)
- besser aber mit dem Tool `yum-config-manager`

Um den `yum-config-manager` nutzen zu können muss das Paket `yum-utils` installiert werden.

----
yum-config-manager --add-repo https://rpms.remirepo.net/enterprise/remi.repo

yum-config-manager --enable-repo baseos-source
----

Liste der verfügbaren Repositories:

----
yum repolist all
----

Repos disablen und enablen:

----
yum-config-manager --disable <reponame>
yum-config-manager --disable updates
yum-config-manager --enable <reponame>
yum-config-manager --enable updates
----

=== Cache leeren

----
# yum clean packages
# yum clean metadata
----

== Paketmanagement bei OpenSUSE

- OpenSUSE verwednet `zypper` als Paketmanagement Tool
- ähnlich wie `apt` und `yum`

=== Paketindex aktualisieren

----
zypper refresh      # Paketindex aktualisieren
----

- pro Repo kann eingestellt werden, ob der Index automatisch aktualiert werden soll

=== nach Paketen suchen

----
zypper search <paketname>      # nach Paketen suche
zypper se <paketname>
zypper se -i              # Liste der installierten Pakete
zypper se -i <string>     # prüfen, ob Pakete installiert mit <string> im Namen installiert sind
zypper se -u <string>     # Suche nach nicht-installierten Paketen
----

=== Installation von Paketen

----
zypper install <paketname>
zypper in <paketname>
----

- mit `zypper` können auch lokal vorhandene `.rpmr` Pakete installiert werden
- Abhängigkeiten werden dabei aufgelöst
- hier muss der absolute Pfad angegeben werden

=== Upgrade von Paketen / des Systems

----
zypper update        # alle installierten Pakete aktualisieren
zypper list-updates  # alle Aktualisierungen anzeigen
----

=== Löschen von Paketen

- beim Entfernen von Paketen werden automatisch alle Pakete mit entfernt, die von dem zu entfernenden Paket abhängen

----
zypper remove <paket>
zypper re <paket>
----

=== Suche nach dem Paket, welches eine Datei enthält

- hierzu wird der Suchparameter `se` mit der Option `--provides` erweitert
- es folgt der absolute Pfad zur Datei

----
# zypper se --provides /usr/lib64/libgimpmodule-2.0.so.0
----

=== Informationen über installierte Pakete

----
# zypper info gimp
----

=== Software Repositories

- Anzeige aller auf dem System registrierten Repositories mit `zypper repos`
- mit der Option `modifyrepo` können Repos konfiguriert werden
- Repos aktivieren und deaktivieren mit `-e` und `-d`:

----
# zypper modifyrepo -d repo-non-oss
Repository 'repo-non-oss' has been successfully disabled.

# zypper modifyrepo -e repo-non-oss
Repository 'repo-non-oss' has been successfully enabled.
----

- _autorefresh_ für ein Repo ein- bzw. ausschalten mit `-f` und `-F`:

----
# zypper modifyrepo -F repo-non-oss
Autorefresh has been disabled for repository 'repo-non-oss'.

# zypper modifyrepo -f repo-non-oss
Autorefresh has been enabled for repository 'repo-non-oss'.
----

- Repos können mit `addrepo` hinzugefügt und mit `removerepo` wieder entfernt werden:

----
# zypper addrepo http://packman.inode.at/suse/openSUSE_Leap_15.1/ packman
----

- beim Hinzufügen können mit `-f` Autoupdates eingeschaltet werden
- wird beim Hinzufügen die Option `-d` mit angegeben, wird das Repo hinzugefügt aber nicht aktiviert

----
# zypper removerepo packman
----

== Regular Expressions

https://www.debuggex.com/

- `.`: ein beliebiges Zeichen

- `\w`: Wordcharacter [a-zA-Z0-9_]
- `\W`: kein Wordcharacter [a-zA-Z0-9_]
- `\d`: Ziffer [0-9]
- `\D`: keine Ziffer [0-9]
- `\s`: Whitespace (Space, Tab, Newline)
- `\S`: kein Whitespace (Space, Tab, Newline)

- `\b`: Wortgrenze
- `\B`: keine Wortgrenze

Listen:

- `[]`: passt auf jedes Zeichen, das in den Klammern angegeben ist
- `[a-z]`: passt auf jeden Kleinbuchstaben
- `[0-9]`: passt auf alle Zahlen

- `()`: Gruppe
- `(entweder|oder)`: passt auf `entweder` oder `oder`

Anker:

-`^`: Anfang der Zeile
- `$`: Ende der Zeile

Quantifier:

- `*`: 0 Mal oder beliebig oft
- `+`: 1 Mal oder beliebig oft
- `?`: 0 Mal oder 1 Mal
- `{3}`: exakt 3 Mal
* `{1,3}`: 1 bis 3 Mal

== Dateien mit gesetzten Sonderbits finden

Wir durchsuchen das gesamte System mit `find` und prüfen so jede Datei auf gesetzte Berechtigungen. Berechtigungen der Sonderbits:

- Sticky-Bit: `1000`
- SGID-Bit: `2000`
- SUID-Bit: `4000`

Alle Dateien, wo *auschließlich* bzw. *exakt* nur das SUID-Bit gesetzt ist:

 find / -perm 4000
 find / -perm u=s
 find / -perm u+s

Alle Dateien, wo *mindestens* nur das SUID-Bit gesetzt ist (`-` vor den Berechtigungen [-> mindestens]):

 find / -perm -4000
 find / -perm -u=s
 find / -perm -u+s

Alle Dateien, wo *entweder* das SUID-Bit oder das SGID-Bit gesetzt ist (`/` or den Berechtigungen [-> entweder oder]):

 find / -perm /6000
 find / -perm /ug=s
 find / -perm /ug+s


== cron

Format Angabe Zeitintervalle:

----
 .---------------- minute (0 - 59)
 |  .------------- hour (0 - 23)
 |  |  .---------- day of month (1 - 31)
 |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
 |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
 |  |  |  |  |
 *  *  *  *  * command to be executed
----

- Es können spezifische Zeitpunkte, Listen von Zeitpunkten (durch Komma getrennt), Bereiche (durch Minuszeichen getrennt) oder Intervalle (Angabe mit Slash `/`) angegebenen werden. Beispiele:

 mon,tue,thu    -> Montag, Dienstag und Donnerstag
 mon-sat        -> Montag bis Samstag
 9-16           -> 9 bis 16 Uhr
 */5            -> alle fünf (z.B. Minuten)

- Dienst, der Aufgaben (`cronjobs`) zu einem bestimmmten Zeitpunkt oder Zeitintervall automatisch ausführt
- `cronjobs` werden *nicht* nachgeholt, sollte der Rechner zu dem angegebenen Zeitpunkt aus sein
- Aufgaben werden in `crontabs` festgelegt
- es gibt Benutzer `crontabs` für jeden Benutzer (auch `root`) und eine systemweite `crontab` unter `/etc/crontab`
- diese unterscheidet sich von den User-crontabs (nur) dadurch, dass es eine zusätzliche Spalte für den auszuführeden Benutzer enthält
- in den Verzeichnissen `/etc/cron.hourly`, `/etc/cron.daily` usw. können Skripte abgelegt werden, die dann periodisch ausgeführt werden
- je nach Distribution können die Verzeichnisse auch `/etc/cron.d/daily` etc. heissen
- User crontabs liegen z.B. unter `/var/spool/cron/crontabs` (distributionsabhängig)
- die User crontab Dateien werden nicht direkt editiert, sondern mit dem Kommando `crontab -e`
- `crontab -r` löscht die crontab des aufrufenden Benutzers
- `crontab -l` zeigt den Inhalt der crontab an
- `root` kann eine User crontab mit dem Kommando `crontab -u <user> -e / -l / -r` editieren, auflisten oder löschen
- Informationen über den Aufbau und die Angabe von Zeiten/Intervallen sind in der Manpage zu finden: `man 5 crontab`, Informationen über das Kommando `crontab` unter `man crontab`
- in den Dateien `/etc/cron.allow` und `/etc/cron.deny` koenne Zugriffe auf den cron Daemon geregelt werden
- existiert die Datei `/etc/cron.allow` können _ausschliesslich_ die darin gelisteten Benutzer (einer pro Zeile) `cron` benutzen
- existiert die Datei `/etc/cron.deny` und *keine* `/etc/cron.allow` können alle *nicht* darin gelisteten Benutzer (einer pro Zeile) `cron` benutzen
- existieren beide Dateien, wird nur `/etc/cron.allow` ausgelesen

== systemd-timer

- `systemd-timer` sind eine Alternative von `systemd` für `cron`
- diese sind Unit Files mit der Endung `.timer`
- für jeden Timer *muss ein Service File vorliegen* (`.service`), welches den Service beschreibt, der zu den im Timer angegebenen Zeitpunkt gestartet wird
- Timer und Service Files müssen den gleichen Namen (bis auf die Endung) haben

Beispiel: Starte den Service `/etc/systemd/system/foobar.service` um 05:30 Uhr am ersten Montag jeden Monats. Falls der Rechner zu diesem Zeitpunkt nicht an sein sollte wird der Timer nachgeholt sobald der Rechner wieder startet (`Persistent=true`):

----
[Unit]
Description=Run the foobar service

[Timer]
OnCalendar=Mon *-*-1..7 05:30:00
Persistent=true

[Install]
WantedBy=timers.target
----

- Syntax/Aufbau Eintrag `OnCalendar=` ähnlich wie bei cronjobs

----
# DayOfWeek Year-Month-Day  Hour:Minute:Second

  Mon       *   - *    1..7 05:30:00

# Alternative Angaben:

  hourly
  daily
  weekly
  monthly
  yearly
----

- generelle Syntax zu Zeitangaben in `systemd` in Manpage `man systemd.time`, spezifischer für Timer unter `CALENDAR EVENTS`
- Angabe der Spalte `DayOfWeek` ist optional
- `*`, `/` und `,` wie in crontabs
- mit `..` kann eine Range angegeben werden (wie `-` in crontabs)
- `timer` müssen wie `services` aktiviert bzw. gestartet werden:

----
systemctl enable foobar.timer
systemctl start foobar.timer

# Alternativ, aktiveren und starten in einem Kommando:
systemctl enable --now foobar.timer
----

- nach einer Änderung an den Unit Files muss noch das Kommando `systemctl daemon-reload` ausgeführt werden
- es können auch sog. _Monotonic Timers_ verwendet werden (`systemd-run`)
- diese werden nach Ablauf einer gewissen Zeit aktiviert (ähnlich wie `at`)

=== at 


- Mit dem Kommanod `at` kann eine bestimmte Aufgabe nach Ablauf einer gewissen Zeit bzw. einmalig zu einem Zeitupunkt ausgeführt werden

----
at now + 5 minutes

at> date
at> Ctrl+D 

job 1 at Mon Dec 04 9:07:00 2023
----

- `at` ist interaktiv
- akzeptiert umgangssprachliche Zeitangaben: `tomorrow`, `noon`, `teatime` etc.
- `at -l` bzw. `atq` zeigt eine Liste der Jobs an
- `at -r`, `at -d`, `atrm` löscht einen bestimmten Job
- `at -b` ist ein Alias auf `batch` (`batch` ist wie `at`, Jobs werden aber nur ausgeführt, wenn die Systemlast es zulässt)

=== systemd-run

- Alternative von `systemd` zu `at`
- muss mit `root`-Rechten ausgeführt werden
- Aufgabe wird nur *einmal* ausgeführt

----
# systemd-run --on-calendar='2023-12-04 10:00' /usr/bin/breakfast-break

# systemd-run --on-active="2m" ./foo.sh
----

== Arten von Shells

- Interaktive / Nicht-interaktive Shells
- Login / Nicht-Login Shells


== Shellscripting

TODO


== Mail Transfer Agent (MTA) basics

- MTA - Mail Transfer Agent (sendmail, postfix, exim, qmail)
- MDA - Mail Delivery Agent (procmail, cyrus, maildrop)
- MUA - Mail User Agent (Thunderbird, Outlook, Enigmail, mutt, kmail, evolution)

TODO

== Logging

=== Programme zur Protokollierung

- `syslogd`: ältester Logging Dienst, heute so gut wie nicht mehr in Gebrauch
- `syslog-ng`: Nachfolger von `syslogd`
- `rsyslog`: lange Zeit Standard der meisten Distribution
- `journald`: bei Verwendung von `systemd`, unterscheidet sich technisch
  erheblich von den anderen

=== rsyslog

- Konfiguration in Datei `/etc/rsyslog.conf` (nicht `/etc/rsyslogd.conf`)oder Dateien unterhalb von `/etc/rsyslog.d/`
- Dateien enthalten Regeln
- jede Zeile besteht aus den drei Komponenten: `facility.level action`:
  - `facility`: Einrichtung, die zu protokollierenden Eintrag erstellt
  - typisch sind: `auth, authpriv, cron, daemon, kern, lpr, mail, mark, news, syslog, user, uucp, local0` bis `local7`
  - Asterisk: alle Einträge
  - `local0` bis `local7`: wenn `Syslog` für eigene Programme verwendet werden soll
- `level`: legt Protokollierungsgrad fest
  - `debug`: externer, in der Regel unnötiger Protokollierungsgrad
  - `info`: harmlose Informatinen
  - `notice`: ungefährliche Hinweise
  - `warning, warn`: normalerweise harmlos
  - `err, error`: z.B. Authentifizierungsfehler, I/O-Fehler ...
  - `crit`: Kritischer Fehler, sorgt immer für Probleme
  - `alert`: Alarm:> schwerwiegendes Problem
  - `emerg, panic`: (wenn überhaupt noch) als letzter Eintrag vor Systemcrash
  - `error, warn, panic` sind veraltet
- `action`: Bezeichnung etwas irreführend: ZIEL, in das das Facility protokollieren soll (normalerweise Datei, kann aber auch anderer Rechner, Benutzerliste)

Auszug aus `rsyslog.conf` (Sektion `RULES`):

----
###############
#### RULES ####
###############

# First some standard log files.  Log by facility.
#
auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
#cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          -/var/log/mail.log
user.*                          -/var/log/user.log

#
# Logging for the mail system.  Split it up so that
# it is easy to write scripts to parse these files.
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

#
# Some "catch-all" log files.
#
*.`debug;\
        auth,authpriv.none;\
	news.none;mail.none     -/var/log/debug
*.`info;*.`notice;*.`warn;\
	auth,authpriv.none;\
	cron,daemon.none;\
	mail,news.none          -/var/log/messages
----

- Logging kann auch auf einem entfernten Rechner erfolgen
- dazu muss das Zielsystem wie folgt vorbereitet werden um Remotelogging sowohl
  für UDP wie auch TCP zu unterstützten:

----
# provides UDP syslog reception
$ModLoad imudp
$UDPServersRun 514
# provides TCP syslog reception
$ModLoad imtcp
$TCPServersRun 514
----

- auf dem System, welches geloggt werden soll, muss folgende Zeile eingetragen werden:

----
*.* 192.168.9.88:513

*.* <IP Remote>:513
----

- es wird zusätzlich lokal geloggt
- die Daten sind nicht verschlüsselt

=== Log Dateien durchsuchen

- mit den bekannten Tools: `less`, `tail -f`, `grep` etc.

----
grep sshd /var/log/syslog | grep invalid | less
----
 
=== /etc/logrotate.conf

- `logrotate` überwacht Log-Dateien, damit sie nciht das System überfluten
- Konfiguration unter `/etc/logrotate.conf` bzw. `/etc/logrotate.d` (hier legen
  üblicherweise Programme ihre eigene Konfiguration ab)
- `logrotate` benennt Logdatei nach Ablauf einer bestimmten Zeit um, mit dem Suffix `.1` und erstellt eine neue
  (leere) Datei
- beim nächsten Durchgang erhält diese Datei den Suffix `.2.gz` und wird
  zusätzlich komprimiert
- Anzahl zu behaltener Dateien sowie Intervall sind konfigurierbar
- sollte täglich von `cron` ausgeführt werden

Auszug aus `logrotate.conf`

----
# rotate log files weekly
weekly

# keep 4 weeks worth of backlogs
rotate 4

# restrict maximum size of log files
#size 20M

# create new (empty) log files after rotating old ones
create

# uncomment this if you want your log files compressed
#compress

# Logs are moved into directory for rotation
# olddir /var/log/archive

# Ignore pacman saved files
tabooext + .pacorig .pacnew .pacsave

# Arch packages drop log rotation information into this directory
include /etc/logrotate.d

/var/log/wtmp {
    monthly
    create 0664 root utmp
    minsize 1M
    rotate 1
}

/var/log/btmp {
    # don't log an error if just one log file is missing
    missingok
    monthly
    create 0600 root utmp
    rotate 1
}

----

Auszug aus einer Datei in `/etc/logrotate.d`:

----
rotate 6
monthly
compress
missingok
notifempty
create 640 www-data adm
----

== journald

- `journald` speichert bereits Meldungen aus dem sog. _Early Boot_, da es in `systemd` integriert ist und somit direkt startet 
- es wird *alles* geloggt, inkl. Metainformationen    
- arbeitet mit sog. _Trustet Facilities_, Einträge werden signiert
- Log-Einträge lassen sich somit im Nachhinein nicht mehr ändern, ohne dass dies nachgewiesen werden kann    
- `journald` loggt nicht mehr in Textdateien, sondern in Datenbanken
- keine Logrotation, `journald` überwacht seine Größe selbst: max. 10% der HD bzw. max 4 GB
- als Kompatibilitätsschicht stellt `journald` die Funktion bereit, Log Meldungen an den `rsyslog` weiterzuleiten. Dazu muss in der Konfigurationsdatei `/etc/system/journald.conf` der Eintrag `ForwardToSyslog`yes` existieren und der Dienst `rsyslog` installiert sein und laufen
- in Debian 12 ist kein `rsyslog` mehr installiert. Obiges Verhalten kann also durch Installation von `rsyslog` wiederhergestellt werden
- `systemd` ist generell modular aufgebaut, man kann also Teile/Module abschalten falls man das möchte
- Das Journal kann entweder in eine Datei auf der Festlplatte erstellt werden oder nur im RAM. Dazu gibt es folgende Einstellungen in der `/etc/systemd/journald.conf`:
  - `Storage`volatile`:  Das Journal besteht nur im RAM    
  - `Storage`auto`:  Journal besteht nur im RAM, es sei denn das Verzeichnis `/var/log/journal` existiert, dann werden darin die Datenbankdateien erstellt
- `Storage`persistent`: Logging auf der Platte, die Datei `/var/log/jounal` wird erstellt falls nicht vorhanden
  - `Storage`none`:  Logging nur auf der Konsole etc.
- `Seal`yes`: Log Meldungen werden _gesealt_, können also nicht unbemerkt verändert werden
- `SystemMaxUse`:  max. Speicherverbrauch definierbar  
- `man journald.conf`: Manpage der journald-Konfigurationsdatei

=== Abfrage des Journals

Als regulärer User kann man nicht alle Log Meldungen sehen. Dies kann man ändern, in dem man den Benutzer der Gruppe `adm` oder `systemd-journal` hinzufügt.

- `jounalctl`: zeigt das komplette journal im Pager `less` an
- `jounalctl --vacuum-size 50M`:  beschränkt das Journal auf 50 MB  
- `jounalctl --vacuum-time 2weeks`: löscht alle Einträge die älter sind als 2 Wochen
- `jounalctl --disk-usage`: gibt die aktuelle Größe des Journals aus
- `jounalctl --verify`: Prüft die Journal-Dateien auf interne Konsistenz, wichtig z.B. nach Verkleinerung, da hier zusammenhängende Logmeldungen erhalten bleiben, die Beschränkung der Größe erfolgt also nicht exakt, sondern logisch
- `jounalctl -b`, `journalctl -b 0`: Einträge des aktuellen Boots anzeigen
- `jounalctl -b -1`  Einträge des vorherigen Boots anzeigen. `-1` ist hier der Offset. Mit `3` würden z.B. die Meldungen des dritten Boots angezeigt werden.
- `journalctl --list-boots` zeigt eine Liste aller Bootvorgänge an
- `jounalctl --since`"20 min ago"`  Meldungen der letzten 20 Min.   
- `journalctl --since yesterday`: Meldungen seit gestern   
- `journalctl --since`'2023-12-01 12.55'` Meldungen seit diesem Zeitpunkt 
- `jounalctl --since`'2023-12-01 12.55' --until'2023-12-01 13.55'` Meldungen zwischen diesen Zeitpunkten
- Zeitangaben sieht `man systemd.time` -> einheitliche Syntax in `systemd` (also wie bei z.B. Timern)
- `jounalctl -n` (_new_) 10 neuste Einträge anzeigen (analog zu `tail`)
- `jounalctl -n 20` 20 neuste Einträge
- `jounalctl -e` (_end_) ans Ende des Logs springen  
- `jounalctl -r`  (_reverse_) umgedrehte Reihenfolge  
- `jounalctl -k` (_kernel_) Kernelmeldungen  
- `jounalctl -p err` (_priority errors_) Angabe der Priority / des Log-Levels _error_
- `jounalctl -u apache2` (_unit_) Anzeigen der Meldungen des _Units_ Apache2 (unter `systemd` ist alles ein _Unit_: Dienste (services), targets, mounts, device, sockets etc.)
- `jounalctl /dev/sda` zeigt Meldungen des Geräts `/dev/sda` an  
- `jounalctl _UID`1000`  Einträge des Nutzers mit der UID 1000

Auch bei Verwendung von `journald` können die Daten auf einen Server zentralisiert gespeichert werden    

Möchte man auf ein Journal einer anderen Maschine zugreifen, so kann man entweder die _Machine ID_ angeben, oder ein Verzeichnis, in dem sich das Journal befindet:

- `journalctl --file`<machine-id>`
- `journalctl -D /var/log/journal/<machine-id>`
- `cat /etc/machine-id` die Machine-ID ausgeben lassen
- Die Machine-ID kennzeichnet ein System eindeutig, ähnlich wie eine UID, PID etc.


=== Selbst Ereignisse loggen

==== Programm logger

- ursprünglich für `rsyslog`
- kann aber auch Einträge ins Journal schreiben

 logger -t Backup "Datensicherung erfolgreich"

 tail -n 1 /var/log/syslog

- unter systemd eher:

 echo "Log as you can" | systemd-cat -t backup-script -p info

 journalctl -e -n 1

== Language and Character Encoding

- Sprache und bestimmte Sonderzeichen werden über die sog. `locale` bestimmt
- die meisten Shell Programme fragen hierzu die Umgebungsvariable `LANG` ab
- das Format ist immer in der Form `language_REGIONCODE`, wie z.B. `de_DE` oder `en_US`
- in dieser Variablen wird ausserdem die Zeichenkodierung gespeichert:

----
$ echo $LANG
de_DE.UTF-8
----

- Datei `/etc/locale.conf`:

----
LANG=en_US.UTF-8
LANGUAGE=en_US:de_DE
LC_TIME=de_DE.UTF-8
LC_COLLATE=C
LC_MESSAGES=POSIX
LC_NUMERIC=de_DE.UTF-8
LC_MONETARY=de_DE.UTF-8
LC_PAPER=de_DE.UTF-8
LC_NAME=de_DE.UTF-8
LC_ADDRESS=de_DE.UTF-8
LC_TELEPHONE=de_DE.UTF-8
LC_MEASUREMENT=en_GB.UTF-8
LC_IDENTIFICATION=de_DE.UTF-8
LC_ALL=
----

- Anpassungen für die momentane und zukünftige Sessions in den Dateien `.bash_profile` oder `.profile`
- Änderungen werden Benutzer unabhängigen Programmen (z.B. Login Display Manager) aber erst nach einem Aus- und wieder Einloggen bewusst
- auf Systemd basierten Systemen kann das Kommanodo `localectl` genutzt werden, um die `locale` zu setzen:

----
localectl set-locale LANG=en_US.UTF-8
----

=== weitere Umgebungsvariablen

- `LC_COLLATE` alphabetische Sortierung
- `LC_TYPE` Behandlung bestimmter Zeichen, z.B. bezüglich Gross- und Kleinschreibung
- `LC_MESSAGES` Anzeigesprache von Programmen (hauptsächlich GNU Programme)
- `LC_MONETARY` Währungseinheit 
- `LC_NUMERIC` Zahlenformat für alle anderen Zahlen
- `LC_TIME` Zeit- und Datumsformat 
- `LC_PAPER` Standardpapiergrösse  
- `LC_ALL` überschreibt alle anderen Variablen (inkl. `LANG`)

=== Kommandos

- Anzeige der aktuell definierten Variablen mit `locale`
- die einzige nicht gesetzte Variable ist `LC_ALL`, welche genutzt werden kann, um temporär alle anderen zu überschreiben
- da auch die Art der alphabetischen Sortierung beeinflusst werden kann, es aber gerade mit Skripten zu Problemen kommen kann was die Sortierung angeht, sollte die Variable `LANG` auf die allgemeine Varianel `C` gesetzt werden (`LANG`C`)
- die Locale `C` ist ausserdem performanter, da hier nur eine einfache byteweiser Vergleich bei der Sortierung durchgeführt wird


=== Encoding Konvertierung

- Dokumente, die in einer anderen Kodierung vorliegen und daher seltsame Zeichen enthalten, können mit dem Kommando `iconv` konvertiert werden:
- Anzeige aller unterstützten Encodings mit `iconv -l` oder `iconv --list`
- anstatt eines Redirects kann auch die Option `-o` für `--output` genutzt werden

----
iconv -f ISO-8859-1 -t UTF-8 original.txt > converted.txt
iconv --from-code=ISO-8859-1 --to-code=UTF-8 original.txt > converted.txt

iconv -c -f UTF-8 -t US-ASCII -o output-ascii.txt input-utf8.txt
iconv -f UTF-8 -t ASCII//TRANSLIT -o output-ascii.txt input-utf8.txt
----

- siehe auch: https://www.howtogeek.com/iconv-command-linux/


